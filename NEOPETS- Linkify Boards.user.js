// ==UserScript==
// @name        NEOPETS: Linkify Boards
// @namespace   cox34-neoscripts
// @match       https://www.neopets.com/neoboards/topic.phtml
// @grant       none
// @version     1.0
// @author      cox34
// @description Linkify neoboards
// ==/UserScript==

//LINKIFY JS RELEASED UNDER THE MIT LICENSE

var linkify = (function (exports) {
	'use strict';

	// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY
	// https://data.iana.org/TLD/tlds-alpha-by-domain.txt
  //neopets doesnt allow links except to certain sites so we dont need all the TLDs
	var tlds = 'co \
com \
net'.split(' ');

  // Internationalized domain names containing non-ASCII

	var utlds = ''.split(' ');

	/**
	 * @template A
	 * @template B
	 * @param {A} target
	 * @param {B} properties
	 * @return {A & B}
	 */
	var assign = function assign(target, properties) {
	  for (var key in properties) {
	    target[key] = properties[key];
	  }

	  return target;
	};

	/**
	 * Finite State Machine generation utilities
	 */
	/**
	 * @template T
	 * @typedef {{ [group: string]: T[] }} Collections
	 */

	/**
	 * @typedef {{ [group: string]: true }} Flags
	 */
	// Keys in scanner Collections instances

	var numeric = 'numeric';
	var ascii = 'ascii';
	var alpha = 'alpha';
	var asciinumeric = 'asciinumeric';
	var alphanumeric = 'alphanumeric';
	var domain = 'domain';
	var emoji = 'emoji';
	var scheme = 'scheme';
	var slashscheme = 'slashscheme';
	var whitespace = 'whitespace';
	/**
	 * @template T
	 * @param {string} name
	 * @param {Collections<T>} groups to register in
	 * @returns {T[]} Current list of tokens in the given collection
	 */

	function registerGroup(name, groups) {
	  if (!(name in groups)) {
	    groups[name] = [];
	  }

	  return groups[name];
	}
	/**
	 * @template T
	 * @param {T} t token to add
	 * @param {Collections<T>} groups
	 * @param {Flags} flags
	 */


	function addToGroups(t, flags, groups) {
	  if (flags[numeric]) {
	    flags[asciinumeric] = true;
	    flags[alphanumeric] = true;
	  }

	  if (flags[ascii]) {
	    flags[asciinumeric] = true;
	    flags[alpha] = true;
	  }

	  if (flags[asciinumeric]) {
	    flags[alphanumeric] = true;
	  }

	  if (flags[alpha]) {
	    flags[alphanumeric] = true;
	  }

	  if (flags[alphanumeric]) {
	    flags[domain] = true;
	  }

	  if (flags[emoji]) {
	    flags[domain] = true;
	  }

	  for (var k in flags) {
	    var group = registerGroup(k, groups);

	    if (group.indexOf(t) < 0) {
	      group.push(t);
	    }
	  }
	}
	/**
	 * @template T
	 * @param {T} t token to check
	 * @param {Collections<T>} groups
	 * @returns {Flags} group flags that contain this token
	 */

	function flagsForToken(t, groups) {
	  var result = {};

	  for (var c in groups) {
	    if (groups[c].indexOf(t) >= 0) {
	      result[c] = true;
	    }
	  }

	  return result;
	}
	/**
	 * @template T
	 * @typedef {null | T } Transition
	 */

	/**
	 * Define a basic state machine state. j is the list of character transitions,
	 * jr is the list of regex-match transitions, jd is the default state to
	 * transition to t is the accepting token type, if any. If this is the terminal
	 * state, then it does not emit a token.
	 *
	 * The template type T represents the type of the token this state accepts. This
	 * should be a string (such as of the token exports in `text.js`) or a
	 * MultiToken subclass (from `multi.js`)
	 *
	 * @template T
	 * @param {T} [token] Token that this state emits
	 */


	function State(token) {
	  if (token === void 0) {
	    token = null;
	  }

	  // this.n = null; // DEBUG: State name

	  /** @type {{ [input: string]: State<T> }} j */
	  this.j = {}; // IMPLEMENTATION 1
	  // this.j = []; // IMPLEMENTATION 2

	  /** @type {[RegExp, State<T>][]} jr */

	  this.jr = [];
	  /** @type {?State<T>} jd */

	  this.jd = null;
	  /** @type {?T} t */

	  this.t = token;
	}
	/**
	 * Scanner token groups
	 * @type Collections<string>
	 */

	State.groups = {};
	State.prototype = {
	  accepts: function accepts() {
	    return !!this.t;
	  },

	  /**
	   * Follow an existing transition from the given input to the next state.
	   * Does not mutate.
	   * @param {string} input character or token type to transition on
	   * @returns {?State<T>} the next state, if any
	   */
	  go: function go(input) {
	    var state = this;
	    var nextState = state.j[input];

	    if (nextState) {
	      return nextState;
	    }

	    for (var i = 0; i < state.jr.length; i++) {
	      var regex = state.jr[i][0];
	      var _nextState = state.jr[i][1]; // note: might be empty to prevent default jump

	      if (_nextState && regex.test(input)) {
	        return _nextState;
	      }
	    } // Nowhere left to jump! Return default, if any


	    return state.jd;
	  },

	  /**
	   * Whether the state has a transition for the given input. Set the second
	   * argument to true to only look for an exact match (and not a default or
	   * regular-expression-based transition)
	   * @param {string} input
	   * @param {boolean} exactOnly
	   */
	  has: function has(input, exactOnly) {
	    if (exactOnly === void 0) {
	      exactOnly = false;
	    }

	    return exactOnly ? input in this.j : !!this.go(input);
	  },

	  /**
	   * Short for "transition all"; create a transition from the array of items
	   * in the given list to the same final resulting state.
	   * @param {string | string[]} inputs Group of inputs to transition on
	   * @param {Transition<T> | State<T>} [next] Transition options
	   * @param {Flags} [flags] Collections flags to add token to
	   * @param {Collections<T>} [groups] Master list of token groups
	   */
	  ta: function ta(inputs, next, flags, groups) {
	    for (var i = 0; i < inputs.length; i++) {
	      this.tt(inputs[i], next, flags, groups);
	    }
	  },

	  /**
	   * Short for "take regexp transition"; defines a transition for this state
	   * when it encounters a token which matches the given regular expression
	   * @param {RegExp} regexp Regular expression transition (populate first)
	   * @param {T | State<T>} [next] Transition options
	   * @param {Flags} [flags] Collections flags to add token to
	   * @param {Collections<T>} [groups] Master list of token groups
	   * @returns {State<T>} taken after the given input
	   */
	  tr: function tr(regexp, next, flags, groups) {
	    groups = groups || State.groups;
	    var nextState;

	    if (next && next.j) {
	      nextState = next;
	    } else {
	      // Token with maybe token groups
	      nextState = new State(next);

	      if (flags && groups) {
	        addToGroups(next, flags, groups);
	      }
	    }

	    this.jr.push([regexp, nextState]);
	    return nextState;
	  },

	  /**
	   * Short for "take transitions", will take as many sequential transitions as
	   * the length of the given input and returns the
	   * resulting final state.
	   * @param {string | string[]} input
	   * @param {T | State<T>} [next] Transition options
	   * @param {Flags} [flags] Collections flags to add token to
	   * @param {Collections<T>} [groups] Master list of token groups
	   * @returns {State<T>} taken after the given input
	   */
	  ts: function ts(input, next, flags, groups) {
	    var state = this;
	    var len = input.length;

	    if (!len) {
	      return state;
	    }

	    for (var i = 0; i < len - 1; i++) {
	      state = state.tt(input[i]);
	    }

	    return state.tt(input[len - 1], next, flags, groups);
	  },

	  /**
	   * Short for "take transition", this is a method for building/working with
	   * state machines.
	   *
	   * If a state already exists for the given input, returns it.
	   *
	   * If a token is specified, that state will emit that token when reached by
	   * the linkify engine.
	   *
	   * If no state exists, it will be initialized with some default transitions
	   * that resemble existing default transitions.
	   *
	   * If a state is given for the second argument, that state will be
	   * transitioned to on the given input regardless of what that input
	   * previously did.
	   *
	   * Specify a token group flags to define groups that this token belongs to.
	   * The token will be added to corresponding entires in the given groups
	   * object.
	   *
	   * @param {string} input character, token type to transition on
	   * @param {T | State<T>} [next] Transition options
	   * @param {Flags} [flags] Collections flags to add token to
	   * @param {Collections<T>} [groups] Master list of groups
	   * @returns {State<T>} taken after the given input
	   */
	  tt: function tt(input, next, flags, groups) {
	    groups = groups || State.groups;
	    var state = this; // Check if existing state given, just a basic transition

	    if (next && next.j) {
	      state.j[input] = next;
	      return next;
	    }

	    var t = next; // Take the transition with the usual default mechanisms and use that as
	    // a template for creating the next state

	    var nextState,
	        templateState = state.go(input);

	    if (templateState) {
	      nextState = new State();
	      assign(nextState.j, templateState.j);
	      nextState.jr.push.apply(nextState.jr, templateState.jr);
	      nextState.jd = templateState.jd;
	      nextState.t = templateState.t;
	    } else {
	      nextState = new State();
	    }

	    if (t) {
	      // Ensure newly token is in the same groups as the old token
	      if (groups) {
	        if (nextState.t && typeof nextState.t === 'string') {
	          var allFlags = assign(flagsForToken(nextState.t, groups), flags);
	          addToGroups(t, allFlags, groups);
	        } else if (flags) {
	          addToGroups(t, flags, groups);
	        }
	      }

	      nextState.t = t; // overwrite anything that was previously there
	    }

	    state.j[input] = nextState;
	    return nextState;
	  }
	}; // Helper functions to improve minification (not exported outside linkifyjs module)

	/**
	 * @template T
	 * @param {State<T>} state
	 * @param {string | string[]} input
	 * @param {Flags} [flags]
	 * @param {Collections<T>} [groups]
	 */

	var ta = function ta(state, input, next, flags, groups) {
	  return state.ta(input, next, flags, groups);
	};
	/**
	 * @template T
	 * @param {State<T>} state
	 * @param {RegExp} regexp
	 * @param {T | State<T>} [next]
	 * @param {Flags} [flags]
	 * @param {Collections<T>} [groups]
	 */

	var tr = function tr(state, regexp, next, flags, groups) {
	  return state.tr(regexp, next, flags, groups);
	};
	/**
	 * @template T
	 * @param {State<T>} state
	 * @param {string | string[]} input
	 * @param {T | State<T>} [next]
	 * @param {Flags} [flags]
	 * @param {Collections<T>} [groups]
	 */

	var ts = function ts(state, input, next, flags, groups) {
	  return state.ts(input, next, flags, groups);
	};
	/**
	 * @template T
	 * @param {State<T>} state
	 * @param {string} input
	 * @param {T | State<T>} [next]
	 * @param {Collections<T>} [groups]
	 * @param {Flags} [flags]
	 */

	var tt = function tt(state, input, next, flags, groups) {
	  return state.tt(input, next, flags, groups);
	};

	/******************************************************************************
	Text Tokens
	Identifiers for token outputs from the regexp scanner
	******************************************************************************/
	// A valid web domain token
	var WORD = 'WORD'; // only contains a-z

	var UWORD = 'UWORD'; // contains letters other than a-z, used for IDN
	// Special case of word

	var LOCALHOST = 'LOCALHOST'; // Valid top-level domain, special case of WORD (see tlds.js)

	var TLD = 'TLD'; // Valid IDN TLD, special case of UWORD (see tlds.js)

	var UTLD = 'UTLD'; // The scheme portion of a web URI protocol. Supported types include: `mailto`,
	// `file`, and user-defined custom protocols. Limited to schemes that contain
	// only letters

	var SCHEME = 'SCHEME'; // Similar to SCHEME, except makes distinction for schemes that must always be
	// followed by `://`, not just `:`. Supported types include `http`, `https`,
	// `ftp`, `ftps`

	var SLASH_SCHEME = 'SLASH_SCHEME'; // Any sequence of digits 0-9

	var NUM = 'NUM'; // Any number of consecutive whitespace characters that are not newline

	var WS = 'WS'; // New line (unix style)

	var NL$1 = 'NL'; // \n
	// Opening/closing bracket classes

	var OPENBRACE = 'OPENBRACE'; // {

	var OPENBRACKET = 'OPENBRACKET'; // [

	var OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <

	var OPENPAREN = 'OPENPAREN'; // (

	var CLOSEBRACE = 'CLOSEBRACE'; // }

	var CLOSEBRACKET = 'CLOSEBRACKET'; // ]

	var CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >

	var CLOSEPAREN = 'CLOSEPAREN'; // )
	// Various symbols

	var AMPERSAND = 'AMPERSAND'; // &

	var APOSTROPHE = 'APOSTROPHE'; // '

	var ASTERISK = 'ASTERISK'; // *

	var AT = 'AT'; // @

	var BACKSLASH = 'BACKSLASH'; // \

	var BACKTICK = 'BACKTICK'; // `

	var CARET = 'CARET'; // ^

	var COLON = 'COLON'; // :

	var COMMA = 'COMMA'; // ,

	var DOLLAR = 'DOLLAR'; // $

	var DOT = 'DOT'; // .

	var EQUALS = 'EQUALS'; // =

	var EXCLAMATION = 'EXCLAMATION'; // !

	var HYPHEN = 'HYPHEN'; // -

	var PERCENT = 'PERCENT'; // %

	var PIPE = 'PIPE'; // |

	var PLUS = 'PLUS'; // +

	var POUND = 'POUND'; // #

	var QUERY = 'QUERY'; // ?

	var QUOTE = 'QUOTE'; // "

	var SEMI = 'SEMI'; // ;

	var SLASH = 'SLASH'; // /

	var TILDE = 'TILDE'; // ~

	var UNDERSCORE = 'UNDERSCORE'; // _
	// Emoji symbol

	var EMOJI$1 = 'EMOJI'; // Default token - anything that is not one of the above

	var SYM = 'SYM';

	var tk = /*#__PURE__*/Object.freeze({
		__proto__: null,
		WORD: WORD,
		UWORD: UWORD,
		LOCALHOST: LOCALHOST,
		TLD: TLD,
		UTLD: UTLD,
		SCHEME: SCHEME,
		SLASH_SCHEME: SLASH_SCHEME,
		NUM: NUM,
		WS: WS,
		NL: NL$1,
		OPENBRACE: OPENBRACE,
		OPENBRACKET: OPENBRACKET,
		OPENANGLEBRACKET: OPENANGLEBRACKET,
		OPENPAREN: OPENPAREN,
		CLOSEBRACE: CLOSEBRACE,
		CLOSEBRACKET: CLOSEBRACKET,
		CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,
		CLOSEPAREN: CLOSEPAREN,
		AMPERSAND: AMPERSAND,
		APOSTROPHE: APOSTROPHE,
		ASTERISK: ASTERISK,
		AT: AT,
		BACKSLASH: BACKSLASH,
		BACKTICK: BACKTICK,
		CARET: CARET,
		COLON: COLON,
		COMMA: COMMA,
		DOLLAR: DOLLAR,
		DOT: DOT,
		EQUALS: EQUALS,
		EXCLAMATION: EXCLAMATION,
		HYPHEN: HYPHEN,
		PERCENT: PERCENT,
		PIPE: PIPE,
		PLUS: PLUS,
		POUND: POUND,
		QUERY: QUERY,
		QUOTE: QUOTE,
		SEMI: SEMI,
		SLASH: SLASH,
		TILDE: TILDE,
		UNDERSCORE: UNDERSCORE,
		EMOJI: EMOJI$1,
		SYM: SYM
	});

	// Note that these two Unicode ones expand into a really big one with Babel
	var ASCII_LETTER = /[a-z]/;
	var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/; // Any Unicode character with letter data type

	var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/; // Any Unicode emoji character

	var EMOJI_VARIATION$1 = /\ufe0f/;
	var DIGIT = /\d/;
	var SPACE = /\s/;

	var regexp = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ASCII_LETTER: ASCII_LETTER,
		LETTER: LETTER,
		EMOJI: EMOJI,
		EMOJI_VARIATION: EMOJI_VARIATION$1,
		DIGIT: DIGIT,
		SPACE: SPACE
	});

	/**
		The scanner provides an interface that takes a string of text as input, and
		outputs an array of tokens instances that can be used for easy URL parsing.
	*/
	var NL = '\n'; // New line character

	var EMOJI_VARIATION = "\uFE0F"; // Variation selector, follows heart and others

	var EMOJI_JOINER = "\u200D"; // zero-width joiner

	/**
	 * Scanner output token:
	 * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')
	 * - `v` is the value of the token (e.g., '123', '❤️', 'com')
	 * - `s` is the start index of the token in the original string
	 * - `e` is the end index of the token in the original string
	 * @typedef {{t: string, v: string, s: number, e: number}} Token
	 */

	/**
	 * @template T
	 * @typedef {{ [collection: string]: T[] }} Collections
	 */

	/**
	 * Initialize the scanner character-based state machine for the given start
	 * state
	 * @param {[string, boolean][]} customSchemes List of custom schemes, where each
	 * item is a length-2 tuple with the first element set to the string scheme, and
	 * the second element set to `true` if the `://` after the scheme is optional
	 */

	function init$2(customSchemes) {
	  var _tr, _tr2, _tr3, _tr4, _tt, _tr5;

	  if (customSchemes === void 0) {
	    customSchemes = [];
	  }

	  // Frequently used states (name argument removed during minification)

	  /** @type Collections<string> */
	  var groups = {}; // of tokens

	  State.groups = groups;
	  /** @type State<string> */

	  var Start = new State(); // States for special URL symbols that accept immediately after start

	  tt(Start, "'", APOSTROPHE);
	  tt(Start, '{', OPENBRACE);
	  tt(Start, '[', OPENBRACKET);
	  tt(Start, '<', OPENANGLEBRACKET);
	  tt(Start, '(', OPENPAREN);
	  tt(Start, '}', CLOSEBRACE);
	  tt(Start, ']', CLOSEBRACKET);
	  tt(Start, '>', CLOSEANGLEBRACKET);
	  tt(Start, ')', CLOSEPAREN);
	  tt(Start, '&', AMPERSAND);
	  tt(Start, '*', ASTERISK);
	  tt(Start, '@', AT);
	  tt(Start, '`', BACKTICK);
	  tt(Start, '^', CARET);
	  tt(Start, ':', COLON);
	  tt(Start, ',', COMMA);
	  tt(Start, '$', DOLLAR);
	  tt(Start, '.', DOT);
	  tt(Start, '=', EQUALS);
	  tt(Start, '!', EXCLAMATION);
	  tt(Start, '-', HYPHEN);
	  tt(Start, '%', PERCENT);
	  tt(Start, '|', PIPE);
	  tt(Start, '+', PLUS);
	  tt(Start, '#', POUND);
	  tt(Start, '?', QUERY);
	  tt(Start, '"', QUOTE);
	  tt(Start, '/', SLASH);
	  tt(Start, ';', SEMI);
	  tt(Start, '~', TILDE);
	  tt(Start, '_', UNDERSCORE);
	  tt(Start, '\\', BACKSLASH);
	  var Num = tr(Start, DIGIT, NUM, (_tr = {}, _tr[numeric] = true, _tr));
	  tr(Num, DIGIT, Num); // State which emits a word token

	  var Word = tr(Start, ASCII_LETTER, WORD, (_tr2 = {}, _tr2[ascii] = true, _tr2));
	  tr(Word, ASCII_LETTER, Word); // Same as previous, but specific to non-fsm.ascii alphabet words

	  var UWord = tr(Start, LETTER, UWORD, (_tr3 = {}, _tr3[alpha] = true, _tr3));
	  tr(UWord, ASCII_LETTER); // Non-accepting

	  tr(UWord, LETTER, UWord); // Whitespace jumps
	  // Tokens of only non-newline whitespace are arbitrarily long
	  // If any whitespace except newline, more whitespace!

	  var Ws = tr(Start, SPACE, WS, (_tr4 = {}, _tr4[whitespace] = true, _tr4));
	  tt(Start, NL, NL$1, (_tt = {}, _tt[whitespace] = true, _tt));
	  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces

	  tr(Ws, SPACE, Ws); // Emoji tokens. They are not grouped by the scanner except in cases where a
	  // zero-width joiner is present

	  var Emoji = tr(Start, EMOJI, EMOJI$1, (_tr5 = {}, _tr5[emoji] = true, _tr5));
	  tr(Emoji, EMOJI, Emoji);
	  tt(Emoji, EMOJI_VARIATION, Emoji); // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy

	  var EmojiJoiner = tt(Emoji, EMOJI_JOINER);
	  tr(EmojiJoiner, EMOJI, Emoji); // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy
	  // Generates states for top-level domains
	  // Note that this is most accurate when tlds are in alphabetical order

	  var wordjr = [[ASCII_LETTER, Word]];
	  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];

	  for (var i = 0; i < tlds.length; i++) {
	    fastts(Start, tlds[i], TLD, WORD, wordjr);
	  }

	  for (var _i = 0; _i < utlds.length; _i++) {
	    fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);
	  }

	  addToGroups(TLD, {
	    tld: true,
	    ascii: true
	  }, groups);
	  addToGroups(UTLD, {
	    utld: true,
	    alpha: true
	  }, groups); // Collect the states generated by different protocols. NOTE: If any new TLDs
	  // get added that are also protocols, set the token to be the same as the
	  // protocol to ensure parsing works as expected.

	  fastts(Start, 'file', SCHEME, WORD, wordjr);
	  fastts(Start, 'mailto', SCHEME, WORD, wordjr);
	  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);
	  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);
	  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);
	  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);
	  addToGroups(SCHEME, {
	    scheme: true,
	    ascii: true
	  }, groups);
	  addToGroups(SLASH_SCHEME, {
	    slashscheme: true,
	    ascii: true
	  }, groups); // Register custom schemes. Assumes each scheme is asciinumeric with hyphens

	  customSchemes = customSchemes.sort(function (a, b) {
	    return a[0] > b[0] ? 1 : -1;
	  });

	  for (var _i2 = 0; _i2 < customSchemes.length; _i2++) {
	    var _ref, _ref2;

	    var sch = customSchemes[_i2][0];
	    var optionalSlashSlash = customSchemes[_i2][1];
	    var flags = optionalSlashSlash ? (_ref = {}, _ref[scheme] = true, _ref) : (_ref2 = {}, _ref2[slashscheme] = true, _ref2);

	    if (sch.indexOf('-') >= 0) {
	      flags[domain] = true;
	    } else if (!ASCII_LETTER.test(sch)) {
	      flags[numeric] = true; // numbers only
	    } else if (DIGIT.test(sch)) {
	      flags[asciinumeric] = true;
	    } else {
	      flags[ascii] = true;
	    }

	    ts(Start, sch, sch, flags);
	  } // Localhost token


	  ts(Start, 'localhost', LOCALHOST, {
	    ascii: true
	  }); // Set default transition for start state (some symbol)

	  Start.jd = new State(SYM);
	  return {
	    start: Start,
	    tokens: assign({
	      groups: groups
	    }, tk)
	  };
	}
	/**
		Given a string, returns an array of TOKEN instances representing the
		composition of that string.

		@method run
		@param {State<string>} start scanner starting state
		@param {string} str input string to scan
		@return {Token[]} list of tokens, each with a type and value
	*/

	function run$1(start, str) {
	  // State machine is not case sensitive, so input is tokenized in lowercased
	  // form (still returns regular case). Uses selective `toLowerCase` because
	  // lowercasing the entire string causes the length and character position to
	  // vary in some non-English strings with V8-based runtimes.
	  var iterable = stringToArray(str.replace(/[A-Z]/g, function (c) {
	    return c.toLowerCase();
	  }));
	  var charCount = iterable.length; // <= len if there are emojis, etc

	  var tokens = []; // return value
	  // cursor through the string itself, accounting for characters that have
	  // width with length 2 such as emojis

	  var cursor = 0; // Cursor through the array-representation of the string

	  var charCursor = 0; // Tokenize the string

	  while (charCursor < charCount) {
	    var state = start;
	    var nextState = null;
	    var tokenLength = 0;
	    var latestAccepting = null;
	    var sinceAccepts = -1;
	    var charsSinceAccepts = -1;

	    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
	      state = nextState; // Keep track of the latest accepting state

	      if (state.accepts()) {
	        sinceAccepts = 0;
	        charsSinceAccepts = 0;
	        latestAccepting = state;
	      } else if (sinceAccepts >= 0) {
	        sinceAccepts += iterable[charCursor].length;
	        charsSinceAccepts++;
	      }

	      tokenLength += iterable[charCursor].length;
	      cursor += iterable[charCursor].length;
	      charCursor++;
	    } // Roll back to the latest accepting state


	    cursor -= sinceAccepts;
	    charCursor -= charsSinceAccepts;
	    tokenLength -= sinceAccepts; // No more jumps, just make a new token from the last accepting one

	    tokens.push({
	      t: latestAccepting.t,
	      // token type/name
	      v: str.slice(cursor - tokenLength, cursor),
	      // string value
	      s: cursor - tokenLength,
	      // start index
	      e: cursor // end index (excluding)

	    });
	  }

	  return tokens;
	}
	/**
	 * Convert a String to an Array of characters, taking into account that some
	 * characters like emojis take up two string indexes.
	 *
	 * Adapted from core-js (MIT license)
	 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
	 *
	 * @function stringToArray
	 * @param {string} str
	 * @returns {string[]}
	 */

	function stringToArray(str) {
	  var result = [];
	  var len = str.length;
	  var index = 0;

	  while (index < len) {
	    var first = str.charCodeAt(index);
	    var second = void 0;
	    var char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character
	    : str.slice(index, index + 2); // two-index characters

	    result.push(char);
	    index += char.length;
	  }

	  return result;
	}
	/**
	 * Fast version of ts function for when transition defaults are well known
	 * @param {State<string>} state
	 * @param {string} input
	 * @param {string} t
	 * @param {string} defaultt
	 * @param {[RegExp, State<string>][]} jr
	 * @returns {State<string>}
	 */

	function fastts(state, input, t, defaultt, jr) {
	  var next;
	  var len = input.length;

	  for (var i = 0; i < len - 1; i++) {
	    var char = input[i];

	    if (state.j[char]) {
	      next = state.j[char];
	    } else {
	      next = new State(defaultt);
	      next.jr = jr.slice();
	      state.j[char] = next;
	    }

	    state = next;
	  }

	  next = new State(t);
	  next.jr = jr.slice();
	  state.j[input[len - 1]] = next;
	  return next;
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;

	  _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	/**
	 * An object where each key is a valid DOM Event Name such as `click` or `focus`
	 * and each value is an event handler function.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/Element#events
	 * @typedef {?{ [event: string]: Function }} EventListeners
	 */

	/**
	 * All formatted properties required to render a link, including `tagName`,
	 * `attributes`, `content` and `eventListeners`.
	 * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,
	 * eventListeners: EventListeners }} IntermediateRepresentation
	 */

	/**
	 * Specify either an object described by the template type `O` or a function.
	 *
	 * The function takes a string value (usually the link's href attribute), the
	 * link type (`'url'`, `'hashtag`', etc.) and an internal token representation
	 * of the link. It should return an object of the template type `O`
	 * @template O
	 * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj
	 */

	/**
	 * Specify either a function described by template type `F` or an object.
	 *
	 * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each
	 * value should be a function with template type `F` that is called when the
	 * corresponding link type is encountered.
	 * @template F
	 * @typedef {F | { [type: string]: F}} OptFn
	 */

	/**
	 * Specify either a value with template type `V`, a function that returns `V` or
	 * an object where each value resolves to `V`.
	 *
	 * The function takes a string value (usually the link's href attribute), the
	 * link type (`'url'`, `'hashtag`', etc.) and an internal token representation
	 * of the link. It should return an object of the template type `V`
	 *
	 * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).
	 * Each value should either have type `V` or a function that returns V. This
	 * function similarly takes a string value and a token.
	 *
	 * Example valid types for `Opt<string>`:
	 *
	 * ```js
	 * 'hello'
	 * (value, type, token) => 'world'
	 * { url: 'hello', email: (value, token) => 'world'}
	 * ```
	 * @template V
	 * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt
	 */

	/**
	 * See available options: https://linkify.js.org/docs/options.html
	 * @typedef {{
	 * 	defaultProtocol?: string,
	 *  events?: OptObj<EventListeners>,
	 * 	format?: Opt<string>,
	 * 	formatHref?: Opt<string>,
	 * 	nl2br?: boolean,
	 * 	tagName?: Opt<any>,
	 * 	target?: Opt<string>,
	 * 	rel?: Opt<string>,
	 * 	validate?: Opt<boolean>,
	 * 	truncate?: Opt<number>,
	 * 	className?: Opt<string>,
	 * 	attributes?: OptObj<({ [attr: string]: any })>,
	 *  ignoreTags?: string[],
	 * 	render?: OptFn<((ir: IntermediateRepresentation) => any)>
	 * }} Opts
	 */

	/**
	 * @type Required<Opts>
	 */

	var defaults = {
	  defaultProtocol: 'http',
	  events: null,
	  format: noop,
	  formatHref: noop,
	  nl2br: false,
	  tagName: 'a',
	  target: null,
	  rel: null,
	  validate: true,
	  truncate: Infinity,
	  className: null,
	  attributes: null,
	  ignoreTags: [],
	  render: null
	};
	/**
	 * Utility class for linkify interfaces to apply specified
	 * {@link Opts formatting and rendering options}.
	 *
	 * @param {Opts | Options} [opts] Option value overrides.
	 * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For
	 *   internal use) default render function that determines how to generate an
	 *   HTML element based on a link token's derived tagName, attributes and HTML.
	 *   Similar to render option
	 */

	function Options(opts, defaultRender) {
	  if (defaultRender === void 0) {
	    defaultRender = null;
	  }

	  var o = assign({}, defaults);

	  if (opts) {
	    o = assign(o, opts instanceof Options ? opts.o : opts);
	  } // Ensure all ignored tags are uppercase


	  var ignoredTags = o.ignoreTags;
	  var uppercaseIgnoredTags = [];

	  for (var i = 0; i < ignoredTags.length; i++) {
	    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
	  }
	  /** @protected */


	  this.o = o;

	  if (defaultRender) {
	    this.defaultRender = defaultRender;
	  }

	  this.ignoreTags = uppercaseIgnoredTags;
	}
	Options.prototype = {
	  o: defaults,

	  /**
	   * @type string[]
	   */
	  ignoreTags: [],

	  /**
	   * @param {IntermediateRepresentation} ir
	   * @returns {any}
	   */
	  defaultRender: function defaultRender(ir) {
	    return ir;
	  },

	  /**
	   * Returns true or false based on whether a token should be displayed as a
	   * link based on the user options.
	   * @param {MultiToken} token
	   * @returns {boolean}
	   */
	  check: function check(token) {
	    return this.get('validate', token.toString(), token);
	  },
	  // Private methods

	  /**
	   * Resolve an option's value based on the value of the option and the given
	   * params. If operator and token are specified and the target option is
	   * callable, automatically calls the function with the given argument.
	   * @template {keyof Opts} K
	   * @param {K} key Name of option to use
	   * @param {string} [operator] will be passed to the target option if it's a
	   * function. If not specified, RAW function value gets returned
	   * @param {MultiToken} [token] The token from linkify.tokenize
	   * @returns {Opts[K] | any}
	   */
	  get: function get(key, operator, token) {
	    var isCallable = operator != null;
	    var option = this.o[key];

	    if (!option) {
	      return option;
	    }

	    if (typeof option === 'object') {
	      option = token.t in option ? option[token.t] : defaults[key];

	      if (typeof option === 'function' && isCallable) {
	        option = option(operator, token);
	      }
	    } else if (typeof option === 'function' && isCallable) {
	      option = option(operator, token.t, token);
	    }

	    return option;
	  },

	  /**
	   * @template {keyof Opts} L
	   * @param {L} key Name of options object to use
	   * @param {string} [operator]
	   * @param {MultiToken} [token]
	   * @returns {Opts[L] | any}
	   */
	  getObj: function getObj(key, operator, token) {
	    var obj = this.o[key];

	    if (typeof obj === 'function' && operator != null) {
	      obj = obj(operator, token.t, token);
	    }

	    return obj;
	  },

	  /**
	   * Convert the given token to a rendered element that may be added to the
	   * calling-interface's DOM
	   * @param {MultiToken} token Token to render to an HTML element
	   * @returns {any} Render result; e.g., HTML string, DOM element, React
	   *   Component, etc.
	   */
	  render: function render(token) {
	    var ir = token.render(this); // intermediate representation

	    var renderFn = this.get('render', null, token) || this.defaultRender;
	    return renderFn(ir, token.t, token);
	  }
	};

	function noop(val) {
	  return val;
	}

	var options = /*#__PURE__*/Object.freeze({
		__proto__: null,
		defaults: defaults,
		Options: Options,
		assign: assign
	});

	/******************************************************************************
		Multi-Tokens
		Tokens composed of arrays of TextTokens
	******************************************************************************/

	/**
	 * @param {string} value
	 * @param {Token[]} tokens
	 */

	function MultiToken(value, tokens) {
	  this.t = 'token';
	  this.v = value;
	  this.tk = tokens;
	}
	/**
	 * Abstract class used for manufacturing tokens of text tokens. That is rather
	 * than the value for a token being a small string of text, it's value an array
	 * of text tokens.
	 *
	 * Used for grouping together URLs, emails, hashtags, and other potential
	 * creations.
	 * @class MultiToken
	 * @property {string} t
	 * @property {string} v
	 * @property {Token[]} tk
	 * @abstract
	 */

	MultiToken.prototype = {
	  isLink: false,

	  /**
	   * Return the string this token represents.
	   * @return {string}
	   */
	  toString: function toString() {
	    return this.v;
	  },

	  /**
	   * What should the value for this token be in the `href` HTML attribute?
	   * Returns the `.toString` value by default.
	   * @param {string} [scheme]
	   * @return {string}
	  */
	  toHref: function toHref(scheme) {
	    return this.toString();
	  },

	  /**
	   * @param {Options} options Formatting options
	   * @returns {string}
	   */
	  toFormattedString: function toFormattedString(options) {
	    var val = this.toString();
	    var truncate = options.get('truncate', val, this);
	    var formatted = options.get('format', val, this);
	    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;
	  },

	  /**
	   *
	   * @param {Options} options
	   * @returns {string}
	   */
	  toFormattedHref: function toFormattedHref(options) {
	    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);
	  },

	  /**
	   * The start index of this token in the original input string
	   * @returns {number}
	   */
	  startIndex: function startIndex() {
	    return this.tk[0].s;
	  },

	  /**
	   * The end index of this token in the original input string (up to this
	   * index but not including it)
	   * @returns {number}
	   */
	  endIndex: function endIndex() {
	    return this.tk[this.tk.length - 1].e;
	  },

	  /**
	  	Returns an object  of relevant values for this token, which includes keys
	  	* type - Kind of token ('url', 'email', etc.)
	  	* value - Original text
	  	* href - The value that should be added to the anchor tag's href
	  		attribute
	  		@method toObject
	  	@param {string} [protocol] `'http'` by default
	  */
	  toObject: function toObject(protocol) {
	    if (protocol === void 0) {
	      protocol = defaults.defaultProtocol;
	    }

	    return {
	      type: this.t,
	      value: this.toString(),
	      isLink: this.isLink,
	      href: this.toHref(protocol),
	      start: this.startIndex(),
	      end: this.endIndex()
	    };
	  },

	  /**
	   *
	   * @param {Options} options Formatting option
	   */
	  toFormattedObject: function toFormattedObject(options) {
	    return {
	      type: this.t,
	      value: this.toFormattedString(options),
	      isLink: this.isLink,
	      href: this.toFormattedHref(options),
	      start: this.startIndex(),
	      end: this.endIndex()
	    };
	  },

	  /**
	   * Whether this token should be rendered as a link according to the given options
	   * @param {Options} options
	   * @returns {boolean}
	   */
	  validate: function validate(options) {
	    return options.get('validate', this.toString(), this);
	  },

	  /**
	   * Return an object that represents how this link should be rendered.
	   * @param {Options} options Formattinng options
	   */
	  render: function render(options) {
	    var token = this;
	    var href = this.toFormattedHref(options);
	    var tagName = options.get('tagName', href, token);
	    var content = this.toFormattedString(options);
	    var attributes = {};
	    var className = options.get('className', href, token);
	    var target = options.get('target', href, token);
	    var rel = options.get('rel', href, token);
	    var attrs = options.getObj('attributes', href, token);
	    var eventListeners = options.getObj('events', href, token);
	    attributes.href = href;

	    if (className) {
	      attributes.class = className;
	    }

	    if (target) {
	      attributes.target = target;
	    }

	    if (rel) {
	      attributes.rel = rel;
	    }

	    if (attrs) {
	      assign(attributes, attrs);
	    }

	    return {
	      tagName: tagName,
	      attributes: attributes,
	      content: content,
	      eventListeners: eventListeners
	    };
	  }
	}; // Base token
	/**
	 * Create a new token that can be emitted by the parser state machine
	 * @param {string} type readable type of the token
	 * @param {object} props properties to assign or override, including isLink = true or false
	 * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class
	 */

	function createTokenClass(type, props) {
	  var Token = /*#__PURE__*/function (_MultiToken) {
	    _inheritsLoose(Token, _MultiToken);

	    function Token(value, tokens) {
	      var _this;

	      _this = _MultiToken.call(this, value, tokens) || this;
	      _this.t = type;
	      return _this;
	    }

	    return Token;
	  }(MultiToken);

	  for (var p in props) {
	    Token.prototype[p] = props[p];
	  }

	  Token.t = type;
	  return Token;
	}
	/**
		Represents a list of tokens making up a valid email address
	*/

	var Email = createTokenClass('email', {
	  isLink: true,
	  toHref: function toHref() {
	    return 'mailto:' + this.toString();
	  }
	});
	/**
		Represents some plain text
	*/

	var Text = createTokenClass('text');
	/**
		Multi-linebreak token - represents a line break
		@class Nl
	*/

	var Nl = createTokenClass('nl');
	/**
		Represents a list of text tokens making up a valid URL
		@class Url
	*/

	var Url = createTokenClass('url', {
	  isLink: true,

	  /**
	  	Lowercases relevant parts of the domain and adds the protocol if
	  	required. Note that this will not escape unsafe HTML characters in the
	  	URL.
	  		@param {string} [scheme] default scheme (e.g., 'https')
	  	@return {string} the full href
	  */
	  toHref: function toHref(scheme) {
	    if (scheme === void 0) {
	      scheme = defaults.defaultProtocol;
	    }

	    // Check if already has a prefix scheme
	    return this.hasProtocol() ? this.v : scheme + "://" + this.v;
	  },

	  /**
	   * Check whether this URL token has a protocol
	   * @return {boolean}
	   */
	  hasProtocol: function hasProtocol() {
	    var tokens = this.tk;
	    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
	  }
	});

	var multi = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MultiToken: MultiToken,
		Base: MultiToken,
		createTokenClass: createTokenClass,
		Email: Email,
		Text: Text,
		Nl: Nl,
		Url: Url
	});

	/**
		Not exactly parser, more like the second-stage scanner (although we can
		theoretically hotswap the code here with a real parser in the future... but
		for a little URL-finding utility abstract syntax trees may be a little
		overkill).

		URL format: http://en.wikipedia.org/wiki/URI_scheme
		Email format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in
		reference)

		@module linkify
		@submodule parser
		@main run
	*/

	var makeState = function makeState(arg) {
	  return new State(arg);
	};
	/**
	 * Generate the parser multi token-based state machine
	 * @param {{ groups: Collections<string> }} tokens
	 */


	function init$1(_ref) {
	  var groups = _ref.groups;
	  // Types of characters the URL can definitely end in
	  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]); // Types of tokens that can follow a URL and be part of the query string
	  // but cannot be the very last characters
	  // Characters that cannot appear in the URL at all should be excluded

	  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI]; // For addresses without the mailto prefix
	  // Tokens allowed in the localpart of the email

	  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE]; // The universal starting state.

	  /**
	   * @type State<Token>
	   */

	  var Start = makeState();
	  var Localpart = tt(Start, TILDE); // Local part of the email address

	  ta(Localpart, localpartAccepting, Localpart);
	  ta(Localpart, groups.domain, Localpart);
	  var Domain = makeState(),
	      Scheme = makeState(),
	      SlashScheme = makeState();
	  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)

	  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'

	  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'

	  ta(Domain, localpartAccepting, Localpart);
	  ta(Domain, groups.domain, Domain);
	  var LocalpartAt = tt(Domain, AT); // Local part of the email address plus @

	  tt(Localpart, AT, LocalpartAt); // close to an email address now

	  var LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)

	  ta(LocalpartDot, localpartAccepting, Localpart);
	  ta(LocalpartDot, groups.domain, Localpart);
	  var EmailDomain = makeState();
	  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name

	  ta(EmailDomain, groups.domain, EmailDomain);
	  var EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT

	  ta(EmailDomainDot, groups.domain, EmailDomain);
	  var Email$1 = makeState(Email); // Possible email address (could have more tlds)

	  ta(EmailDomainDot, groups.tld, Email$1);
	  ta(EmailDomainDot, groups.utld, Email$1);
	  tt(LocalpartAt, LOCALHOST, Email$1); // Hyphen can jump back to a domain name

	  var EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name

	  ta(EmailDomainHyphen, groups.domain, EmailDomain);
	  ta(Email$1, groups.domain, EmailDomain);
	  tt(Email$1, DOT, EmailDomainDot);
	  tt(Email$1, HYPHEN, EmailDomainHyphen); // Final possible email states

	  var EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)

	  /*const EmailColonPort = */

	  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner
	  // Account for dots and hyphens. Hyphens are usually parts of domain names
	  // (but not TLDs)

	  var DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen

	  var DomainDot = tt(Domain, DOT); // domain followed by DOT

	  ta(DomainHyphen, groups.domain, Domain);
	  ta(DomainDot, localpartAccepting, Localpart);
	  ta(DomainDot, groups.domain, Domain);
	  var DomainDotTld = makeState(Url); // Simplest possible URL with no query string

	  ta(DomainDot, groups.tld, DomainDotTld);
	  ta(DomainDot, groups.utld, DomainDotTld);
	  ta(DomainDotTld, groups.domain, Domain);
	  ta(DomainDotTld, localpartAccepting, Localpart);
	  tt(DomainDotTld, DOT, DomainDot);
	  tt(DomainDotTld, HYPHEN, DomainHyphen);
	  tt(DomainDotTld, AT, LocalpartAt);
	  var DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)

	  var DomainDotTldColonPort = makeState(Url); // TLD followed by a port number

	  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort); // Long URL with optional port and maybe query string

	  var Url$1 = makeState(Url); // URL with extra symbols at the end, followed by an opening bracket

	  var UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)
	  // Query strings

	  ta(Url$1, qsAccepting, Url$1);
	  ta(Url$1, qsNonAccepting, UrlNonaccept);
	  ta(UrlNonaccept, qsAccepting, Url$1);
	  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept); // Become real URLs after `SLASH` or `COLON NUM SLASH`
	  // Here works with or without scheme:// prefix

	  tt(DomainDotTld, SLASH, Url$1);
	  tt(DomainDotTldColonPort, SLASH, Url$1); // Note that domains that begin with schemes are treated slighly differently

	  var UriPrefix = tt(Scheme, COLON); // e.g., 'mailto:' or 'http://'

	  var SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'

	  var SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'

	  tt(SlashSchemeColonSlash, SLASH, UriPrefix); // Scheme states can transition to domain states

	  ta(Scheme, groups.domain, Domain);
	  tt(Scheme, DOT, DomainDot);
	  tt(Scheme, HYPHEN, DomainHyphen);
	  ta(SlashScheme, groups.domain, Domain);
	  tt(SlashScheme, DOT, DomainDot);
	  tt(SlashScheme, HYPHEN, DomainHyphen); // Force URL with scheme prefix followed by anything sane

	  ta(UriPrefix, groups.domain, Url$1);
	  tt(UriPrefix, SLASH, Url$1); // URL, followed by an opening bracket

	  var UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {

	  var UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [

	  var UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <

	  var UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (

	  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);
	  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);
	  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);
	  tt(UrlNonaccept, OPENPAREN, UrlOpenparen); // Closing bracket component. This character WILL be included in the URL

	  tt(UrlOpenbrace, CLOSEBRACE, Url$1);
	  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);
	  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);
	  tt(UrlOpenparen, CLOSEPAREN, Url$1);
	  tt(UrlOpenbrace, CLOSEBRACE, Url$1); // URL that beings with an opening bracket, followed by a symbols.
	  // Note that the final state can still be `UrlOpenbrace` (if the URL only
	  // has a single opening bracket for some reason).

	  var UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it

	  var UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it

	  var UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it

	  var UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it

	  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);
	  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);
	  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);
	  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);
	  var UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it

	  var UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it

	  var UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it

	  var UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it

	  ta(UrlOpenbrace, qsNonAccepting);
	  ta(UrlOpenbracket, qsNonAccepting);
	  ta(UrlOpenanglebracket, qsNonAccepting);
	  ta(UrlOpenparen, qsNonAccepting); // URL that begins with an opening bracket, followed by some symbols

	  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);
	  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);
	  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);
	  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);
	  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);
	  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);
	  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);
	  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);
	  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);
	  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);
	  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);
	  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);
	  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);
	  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);
	  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);
	  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms); // Close brace/bracket to become regular URL

	  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);
	  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);
	  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);
	  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);
	  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);
	  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);
	  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);
	  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);
	  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state

	  tt(Start, NL$1, Nl); // single new line

	  return {
	    start: Start,
	    tokens: tk
	  };
	}
	/**
	 * Run the parser state machine on a list of scanned string-based tokens to
	 * create a list of multi tokens, each of which represents a URL, email address,
	 * plain text, etc.
	 *
	 * @param {State<MultiToken>} start parser start state
	 * @param {string} input the original input used to generate the given tokens
	 * @param {Token[]} tokens list of scanned tokens
	 * @returns {MultiToken[]}
	 */

	function run(start, input, tokens) {
	  var len = tokens.length;
	  var cursor = 0;
	  var multis = [];
	  var textTokens = [];

	  while (cursor < len) {
	    var state = start;
	    var secondState = null;
	    var nextState = null;
	    var multiLength = 0;
	    var latestAccepting = null;
	    var sinceAccepts = -1;

	    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
	      // Starting tokens with nowhere to jump to.
	      // Consider these to be just plain text
	      textTokens.push(tokens[cursor++]);
	    }

	    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
	      // Get the next state
	      secondState = null;
	      state = nextState; // Keep track of the latest accepting state

	      if (state.accepts()) {
	        sinceAccepts = 0;
	        latestAccepting = state;
	      } else if (sinceAccepts >= 0) {
	        sinceAccepts++;
	      }

	      cursor++;
	      multiLength++;
	    }

	    if (sinceAccepts < 0) {
	      // No accepting state was found, part of a regular text token add
	      // the first text token to the text tokens array and try again from
	      // the next
	      cursor -= multiLength;

	      if (cursor < len) {
	        textTokens.push(tokens[cursor]);
	        cursor++;
	      }
	    } else {
	      // Accepting state!
	      // First close off the textTokens (if available)
	      if (textTokens.length > 0) {
	        multis.push(initMultiToken(Text, input, textTokens));
	        textTokens = [];
	      } // Roll back to the latest accepting state


	      cursor -= sinceAccepts;
	      multiLength -= sinceAccepts; // Create a new multitoken

	      var Multi = latestAccepting.t;
	      var subtokens = tokens.slice(cursor - multiLength, cursor);
	      multis.push(initMultiToken(Multi, input, subtokens));
	    }
	  } // Finally close off the textTokens (if available)


	  if (textTokens.length > 0) {
	    multis.push(initMultiToken(Text, input, textTokens));
	  }

	  return multis;
	}
	/**
	 * Utility function for instantiating a new multitoken with all the relevant
	 * fields during parsing.
	 * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate
	 * @param {string} input original input string
	 * @param {Token[]} tokens consecutive tokens scanned from input string
	 * @returns {MultiToken}
	 */

	function initMultiToken(Multi, input, tokens) {
	  var startIdx = tokens[0].s;
	  var endIdx = tokens[tokens.length - 1].e;
	  var value = input.slice(startIdx, endIdx);
	  return new Multi(value, tokens);
	}

	var warn = typeof console !== 'undefined' && console && console.warn || function () {};

	var warnAdvice = 'To avoid this warning, please register all custom schemes before invoking linkify the first time.'; // Side-effect initialization state

	var INIT = {
	  scanner: null,
	  parser: null,
	  tokenQueue: [],
	  pluginQueue: [],
	  customSchemes: [],
	  initialized: false
	};
	/**
	 * @typedef {{
	 * 	start: State<string>,
	 * 	tokens: { groups: Collections<string> } & typeof tk
	 * }} ScannerInit
	 */

	/**
	 * @typedef {{
	 * 	start: State<MultiToken>,
	 * 	tokens: typeof multi
	 * }} ParserInit
	 */

	/**
	 * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin
	 */

	/**
	 * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin
	 */

	/**
	 * De-register all plugins and reset the internal state-machine. Used for
	 * testing; not required in practice.
	 * @private
	 */

	function reset() {
	  State.groups = {};
	  INIT.scanner = null;
	  INIT.parser = null;
	  INIT.tokenQueue = [];
	  INIT.pluginQueue = [];
	  INIT.customSchemes = [];
	  INIT.initialized = false;
	}
	/**
	 * Register a token plugin to allow the scanner to recognize additional token
	 * types before the parser state machine is constructed from the results.
	 * @param {string} name of plugin to register
	 * @param {TokenPlugin} plugin function that accepts the scanner state machine
	 * and available scanner tokens and collections and extends the state machine to
	 * recognize additional tokens or groups.
	 */

	function registerTokenPlugin(name, plugin) {
	  if (typeof plugin !== 'function') {
	    throw new Error("linkifyjs: Invalid token plugin " + plugin + " (expects function)");
	  }

	  for (var i = 0; i < INIT.tokenQueue.length; i++) {
	    if (name === INIT.tokenQueue[i][0]) {
	      warn("linkifyjs: token plugin \"" + name + "\" already registered - will be overwritten");
	      INIT.tokenQueue[i] = [name, plugin];
	      return;
	    }
	  }

	  INIT.tokenQueue.push([name, plugin]);

	  if (INIT.initialized) {
	    warn("linkifyjs: already initialized - will not register token plugin \"" + name + "\" until you manually call linkify.init(). " + warnAdvice);
	  }
	}
	/**
	 * Register a linkify plugin
	 * @param {string} name of plugin to register
	 * @param {Plugin} plugin function that accepts the parser state machine and
	 * extends the parser to recognize additional link types
	 */

	function registerPlugin(name, plugin) {
	  if (typeof plugin !== 'function') {
	    throw new Error("linkifyjs: Invalid plugin " + plugin + " (expects function)");
	  }

	  for (var i = 0; i < INIT.pluginQueue.length; i++) {
	    if (name === INIT.pluginQueue[i][0]) {
	      warn("linkifyjs: plugin \"" + name + "\" already registered - will be overwritten");
	      INIT.pluginQueue[i] = [name, plugin];
	      return;
	    }
	  }

	  INIT.pluginQueue.push([name, plugin]);

	  if (INIT.initialized) {
	    warn("linkifyjs: already initialized - will not register plugin \"" + name + "\" until you manually call linkify.init(). " + warnAdvice);
	  }
	}
	/**
	 * Detect URLs with the following additional protocol. Anything with format
	 * "protocol://..." will be considered a link. If `optionalSlashSlash` is set to
	 * `true`, anything with format "protocol:..." will be considered a link.
	 * @param {string} protocol
	 * @param {boolean} [optionalSlashSlash]
	 */

	function registerCustomProtocol(scheme, optionalSlashSlash) {
	  if (optionalSlashSlash === void 0) {
	    optionalSlashSlash = false;
	  }

	  if (INIT.initialized) {
	    warn("linkifyjs: already initialized - will not register custom scheme \"" + scheme + "\" until you manually call linkify.init(). " + warnAdvice);
	  }

	  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {
	    throw new Error('linkifyjs: incorrect scheme format.\n 1. Must only contain digits, lowercase ASCII letters or "-"\n 2. Cannot start or end with "-"\n 3. "-" cannot repeat');
	  }

	  INIT.customSchemes.push([scheme, optionalSlashSlash]);
	}
	/**
	 * Initialize the linkify state machine. Called automatically the first time
	 * linkify is called on a string, but may be called manually as well.
	 */

	function init() {
	  // Initialize scanner state machine and plugins
	  INIT.scanner = init$2(INIT.customSchemes);

	  for (var i = 0; i < INIT.tokenQueue.length; i++) {
	    INIT.tokenQueue[i][1]({
	      scanner: INIT.scanner
	    });
	  } // Initialize parser state machine and plugins


	  INIT.parser = init$1(INIT.scanner.tokens);

	  for (var _i = 0; _i < INIT.pluginQueue.length; _i++) {
	    INIT.pluginQueue[_i][1]({
	      scanner: INIT.scanner,
	      parser: INIT.parser
	    });
	  }

	  INIT.initialized = true;
	}
	/**
	 * Parse a string into tokens that represent linkable and non-linkable sub-components
	 * @param {string} str
	 * @return {MultiToken[]} tokens
	 */

	function tokenize(str) {
	  if (!INIT.initialized) {
	    init();
	  }

	  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
	}
	/**
	 * Find a list of linkable items in the given string.
	 * @param {string} str string to find links in
	 * @param {string | Opts} [type] either formatting options or specific type of
	 * links to find, e.g., 'url' or 'email'
	 * @param {Opts} [opts] formatting options for final output. Cannot be specified
	 * if opts already provided in `type` argument
	*/

	function find(str, type, opts) {
	  if (type === void 0) {
	    type = null;
	  }

	  if (opts === void 0) {
	    opts = null;
	  }

	  if (type && typeof type === 'object') {
	    if (opts) {
	      throw Error("linkifyjs: Invalid link type " + type + "; must be a string");
	    }

	    opts = type;
	    type = null;
	  }

	  var options = new Options(opts);
	  var tokens = tokenize(str);
	  var filtered = [];

	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];

	    if (token.isLink && (!type || token.t === type)) {
	      filtered.push(token.toFormattedObject(options));
	    }
	  }

	  return filtered;
	}
	/**
	 * Is the given string valid linkable text of some sort. Note that this does not
	 * trim the text for you.
	 *
	 * Optionally pass in a second `type` param, which is the type of link to test
	 * for.
	 *
	 * For example,
	 *
	 *     linkify.test(str, 'email');
	 *
	 * Returns `true` if str is a valid email.
	 * @param {string} str string to test for links
	 * @param {string} [type] optional specific link type to look for
	 * @returns boolean true/false
	 */

	function test(str, type) {
	  if (type === void 0) {
	    type = null;
	  }

	  var tokens = tokenize(str);
	  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
	}

	exports.MultiToken = MultiToken;
	exports.Options = Options;
	exports.State = State;
	exports.createTokenClass = createTokenClass;
	exports.find = find;
	exports.init = init;
	exports.multi = multi;
	exports.options = options;
	exports.regexp = regexp;
	exports.registerCustomProtocol = registerCustomProtocol;
	exports.registerPlugin = registerPlugin;
	exports.registerTokenPlugin = registerTokenPlugin;
	exports.reset = reset;
	exports.stringToArray = stringToArray;
	exports.test = test;
	exports.tokenize = tokenize;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({});


var linkifyStr = (function (linkifyjs) {
	'use strict';

	/**
		Convert strings of text into linkable HTML text
	*/

	function escapeText(text) {
	  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}

	function escapeAttr(href) {
	  return href.replace(/"/g, '&quot;');
	}

	function attributesToString(attributes) {
	  var result = [];

	  for (var attr in attributes) {
	    var val = attributes[attr] + '';
	    result.push(attr + "=\"" + escapeAttr(val) + "\"");
	  }

	  return result.join(' ');
	}

	function defaultRender(_ref) {
	  var tagName = _ref.tagName,
	      attributes = _ref.attributes,
	      content = _ref.content;
	  return "<" + tagName + " " + attributesToString(attributes) + ">" + escapeText(content) + "</" + tagName + ">";
	}
	/**
	 * Convert a plan text string to an HTML string with links. Expects that the
	 * given strings does not contain any HTML entities. Use the linkify-html
	 * interface if you need to parse HTML entities.
	 *
	 * @param {string} str string to linkify
	 * @param {import('linkifyjs').Opts} [opts] overridable options
	 * @returns {string}
	 */


	function linkifyStr(str, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  opts = new linkifyjs.Options(opts, defaultRender);
	  var tokens = linkifyjs.tokenize(str);
	  var result = [];

	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];

	    if (token.t === 'nl' && opts.get('nl2br')) {
	      result.push('<br>\n');
	    } else if (!token.isLink || !opts.check(token)) {
	      result.push(escapeText(token.toString()));
	    } else {
	      result.push(opts.render(token));
	    }
	  }

	  return result.join('');
	}

	if (!String.prototype.linkify) {
	  Object.defineProperty(String.prototype, 'linkify', {
	    writable: false,
	    value: function linkify(options) {
	      return linkifyStr(this, options);
	    }
	  });
	}

	return linkifyStr;

})(linkify);

var linkifyHtml = (function (linkifyjs) {
    'use strict';

    /**
     * generated from https://raw.githubusercontent.com/w3c/html/26b5126f96f736f796b9e29718138919dd513744/entities.json
     * do not edit
     */
    var HTML5NamedCharRefs = {
      // We don't need the complete named character reference because linkifyHtml
      // does not modify the escape sequences. We do need &nbsp; so that
      // whitespace is parsed properly. Other types of whitespace should already
      // be accounted for. &gt; &lt; and &quot; are also frequently relevant ones
      amp: "&",
      gt: ">",
      lt: "<",
      nbsp: " ",
      quot: "\""
    };
    var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    var CHARCODE = /^#([0-9]+)$/;
    var NAMED = /^([A-Za-z0-9]+)$/;

    var EntityParser =
    /** @class */
    function () {
      function EntityParser(named) {
        this.named = named;
      }

      EntityParser.prototype.parse = function (entity) {
        if (!entity) {
          return;
        }

        var matches = entity.match(HEXCHARCODE);

        if (matches) {
          return String.fromCharCode(parseInt(matches[1], 16));
        }

        matches = entity.match(CHARCODE);

        if (matches) {
          return String.fromCharCode(parseInt(matches[1], 10));
        }

        matches = entity.match(NAMED);

        if (matches) {
          return this.named[matches[1]] || "&" + matches[1] + ";";
        }
      };

      return EntityParser;
    }();

    var WSP = /[\t\n\f ]/;
    var ALPHA = /[A-Za-z]/;
    var CRLF = /\r\n?/g;

    function isSpace(char) {
      return WSP.test(char);
    }

    function isAlpha(char) {
      return ALPHA.test(char);
    }

    function preprocessInput(input) {
      return input.replace(CRLF, '\n');
    }

    var EventedTokenizer =
    /** @class */
    function () {
      function EventedTokenizer(delegate, entityParser, mode) {
        if (mode === void 0) {
          mode = 'precompile';
        }

        this.delegate = delegate;
        this.entityParser = entityParser;
        this.mode = mode;
        this.state = "beforeData"
        /* beforeData */
        ;
        this.line = -1;
        this.column = -1;
        this.input = '';
        this.index = -1;
        this.tagNameBuffer = '';
        this.states = {
          beforeData: function beforeData() {
            var char = this.peek();

            if (char === '<' && !this.isIgnoredEndTag()) {
              this.transitionTo("tagOpen"
              /* tagOpen */
              );
              this.markTagStart();
              this.consume();
            } else {
              if (this.mode === 'precompile' && char === '\n') {
                var tag = this.tagNameBuffer.toLowerCase();

                if (tag === 'pre' || tag === 'textarea') {
                  this.consume();
                }
              }

              this.transitionTo("data"
              /* data */
              );
              this.delegate.beginData();
            }
          },
          data: function data() {
            var char = this.peek();
            var tag = this.tagNameBuffer;

            if (char === '<' && !this.isIgnoredEndTag()) {
              this.delegate.finishData();
              this.transitionTo("tagOpen"
              /* tagOpen */
              );
              this.markTagStart();
              this.consume();
            } else if (char === '&' && tag !== 'script' && tag !== 'style') {
              this.consume();
              this.delegate.appendToData(this.consumeCharRef() || '&');
            } else {
              this.consume();
              this.delegate.appendToData(char);
            }
          },
          tagOpen: function tagOpen() {
            var char = this.consume();

            if (char === '!') {
              this.transitionTo("markupDeclarationOpen"
              /* markupDeclarationOpen */
              );
            } else if (char === '/') {
              this.transitionTo("endTagOpen"
              /* endTagOpen */
              );
            } else if (char === '@' || char === ':' || isAlpha(char)) {
              this.transitionTo("tagName"
              /* tagName */
              );
              this.tagNameBuffer = '';
              this.delegate.beginStartTag();
              this.appendToTagName(char);
            }
          },
          markupDeclarationOpen: function markupDeclarationOpen() {
            var char = this.consume();

            if (char === '-' && this.peek() === '-') {
              this.consume();
              this.transitionTo("commentStart"
              /* commentStart */
              );
              this.delegate.beginComment();
            } else {
              var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();

              if (maybeDoctype === 'DOCTYPE') {
                this.consume();
                this.consume();
                this.consume();
                this.consume();
                this.consume();
                this.consume();
                this.transitionTo("doctype"
                /* doctype */
                );
                if (this.delegate.beginDoctype) this.delegate.beginDoctype();
              }
            }
          },
          doctype: function doctype() {
            var char = this.consume();

            if (isSpace(char)) {
              this.transitionTo("beforeDoctypeName"
              /* beforeDoctypeName */
              );
            }
          },
          beforeDoctypeName: function beforeDoctypeName() {
            var char = this.consume();

            if (isSpace(char)) {
              return;
            } else {
              this.transitionTo("doctypeName"
              /* doctypeName */
              );
              if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());
            }
          },
          doctypeName: function doctypeName() {
            var char = this.consume();

            if (isSpace(char)) {
              this.transitionTo("afterDoctypeName"
              /* afterDoctypeName */
              );
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());
            }
          },
          afterDoctypeName: function afterDoctypeName() {
            var char = this.consume();

            if (isSpace(char)) {
              return;
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();
              var isPublic = nextSixChars.toUpperCase() === 'PUBLIC';
              var isSystem = nextSixChars.toUpperCase() === 'SYSTEM';

              if (isPublic || isSystem) {
                this.consume();
                this.consume();
                this.consume();
                this.consume();
                this.consume();
                this.consume();
              }

              if (isPublic) {
                this.transitionTo("afterDoctypePublicKeyword"
                /* afterDoctypePublicKeyword */
                );
              } else if (isSystem) {
                this.transitionTo("afterDoctypeSystemKeyword"
                /* afterDoctypeSystemKeyword */
                );
              }
            }
          },
          afterDoctypePublicKeyword: function afterDoctypePublicKeyword() {
            var char = this.peek();

            if (isSpace(char)) {
              this.transitionTo("beforeDoctypePublicIdentifier"
              /* beforeDoctypePublicIdentifier */
              );
              this.consume();
            } else if (char === '"') {
              this.transitionTo("doctypePublicIdentifierDoubleQuoted"
              /* doctypePublicIdentifierDoubleQuoted */
              );
              this.consume();
            } else if (char === "'") {
              this.transitionTo("doctypePublicIdentifierSingleQuoted"
              /* doctypePublicIdentifierSingleQuoted */
              );
              this.consume();
            } else if (char === '>') {
              this.consume();
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            }
          },
          doctypePublicIdentifierDoubleQuoted: function doctypePublicIdentifierDoubleQuoted() {
            var char = this.consume();

            if (char === '"') {
              this.transitionTo("afterDoctypePublicIdentifier"
              /* afterDoctypePublicIdentifier */
              );
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);
            }
          },
          doctypePublicIdentifierSingleQuoted: function doctypePublicIdentifierSingleQuoted() {
            var char = this.consume();

            if (char === "'") {
              this.transitionTo("afterDoctypePublicIdentifier"
              /* afterDoctypePublicIdentifier */
              );
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);
            }
          },
          afterDoctypePublicIdentifier: function afterDoctypePublicIdentifier() {
            var char = this.consume();

            if (isSpace(char)) {
              this.transitionTo("betweenDoctypePublicAndSystemIdentifiers"
              /* betweenDoctypePublicAndSystemIdentifiers */
              );
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else if (char === '"') {
              this.transitionTo("doctypeSystemIdentifierDoubleQuoted"
              /* doctypeSystemIdentifierDoubleQuoted */
              );
            } else if (char === "'") {
              this.transitionTo("doctypeSystemIdentifierSingleQuoted"
              /* doctypeSystemIdentifierSingleQuoted */
              );
            }
          },
          betweenDoctypePublicAndSystemIdentifiers: function betweenDoctypePublicAndSystemIdentifiers() {
            var char = this.consume();

            if (isSpace(char)) {
              return;
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else if (char === '"') {
              this.transitionTo("doctypeSystemIdentifierDoubleQuoted"
              /* doctypeSystemIdentifierDoubleQuoted */
              );
            } else if (char === "'") {
              this.transitionTo("doctypeSystemIdentifierSingleQuoted"
              /* doctypeSystemIdentifierSingleQuoted */
              );
            }
          },
          doctypeSystemIdentifierDoubleQuoted: function doctypeSystemIdentifierDoubleQuoted() {
            var char = this.consume();

            if (char === '"') {
              this.transitionTo("afterDoctypeSystemIdentifier"
              /* afterDoctypeSystemIdentifier */
              );
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);
            }
          },
          doctypeSystemIdentifierSingleQuoted: function doctypeSystemIdentifierSingleQuoted() {
            var char = this.consume();

            if (char === "'") {
              this.transitionTo("afterDoctypeSystemIdentifier"
              /* afterDoctypeSystemIdentifier */
              );
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);
            }
          },
          afterDoctypeSystemIdentifier: function afterDoctypeSystemIdentifier() {
            var char = this.consume();

            if (isSpace(char)) {
              return;
            } else if (char === '>') {
              if (this.delegate.endDoctype) this.delegate.endDoctype();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            }
          },
          commentStart: function commentStart() {
            var char = this.consume();

            if (char === '-') {
              this.transitionTo("commentStartDash"
              /* commentStartDash */
              );
            } else if (char === '>') {
              this.delegate.finishComment();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.delegate.appendToCommentData(char);
              this.transitionTo("comment"
              /* comment */
              );
            }
          },
          commentStartDash: function commentStartDash() {
            var char = this.consume();

            if (char === '-') {
              this.transitionTo("commentEnd"
              /* commentEnd */
              );
            } else if (char === '>') {
              this.delegate.finishComment();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.delegate.appendToCommentData('-');
              this.transitionTo("comment"
              /* comment */
              );
            }
          },
          comment: function comment() {
            var char = this.consume();

            if (char === '-') {
              this.transitionTo("commentEndDash"
              /* commentEndDash */
              );
            } else {
              this.delegate.appendToCommentData(char);
            }
          },
          commentEndDash: function commentEndDash() {
            var char = this.consume();

            if (char === '-') {
              this.transitionTo("commentEnd"
              /* commentEnd */
              );
            } else {
              this.delegate.appendToCommentData('-' + char);
              this.transitionTo("comment"
              /* comment */
              );
            }
          },
          commentEnd: function commentEnd() {
            var char = this.consume();

            if (char === '>') {
              this.delegate.finishComment();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.delegate.appendToCommentData('--' + char);
              this.transitionTo("comment"
              /* comment */
              );
            }
          },
          tagName: function tagName() {
            var char = this.consume();

            if (isSpace(char)) {
              this.transitionTo("beforeAttributeName"
              /* beforeAttributeName */
              );
            } else if (char === '/') {
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
            } else if (char === '>') {
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.appendToTagName(char);
            }
          },
          endTagName: function endTagName() {
            var char = this.consume();

            if (isSpace(char)) {
              this.transitionTo("beforeAttributeName"
              /* beforeAttributeName */
              );
              this.tagNameBuffer = '';
            } else if (char === '/') {
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
              this.tagNameBuffer = '';
            } else if (char === '>') {
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
              this.tagNameBuffer = '';
            } else {
              this.appendToTagName(char);
            }
          },
          beforeAttributeName: function beforeAttributeName() {
            var char = this.peek();

            if (isSpace(char)) {
              this.consume();
              return;
            } else if (char === '/') {
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
              this.consume();
            } else if (char === '>') {
              this.consume();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else if (char === '=') {
              this.delegate.reportSyntaxError('attribute name cannot start with equals sign');
              this.transitionTo("attributeName"
              /* attributeName */
              );
              this.delegate.beginAttribute();
              this.consume();
              this.delegate.appendToAttributeName(char);
            } else {
              this.transitionTo("attributeName"
              /* attributeName */
              );
              this.delegate.beginAttribute();
            }
          },
          attributeName: function attributeName() {
            var char = this.peek();

            if (isSpace(char)) {
              this.transitionTo("afterAttributeName"
              /* afterAttributeName */
              );
              this.consume();
            } else if (char === '/') {
              this.delegate.beginAttributeValue(false);
              this.delegate.finishAttributeValue();
              this.consume();
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
            } else if (char === '=') {
              this.transitionTo("beforeAttributeValue"
              /* beforeAttributeValue */
              );
              this.consume();
            } else if (char === '>') {
              this.delegate.beginAttributeValue(false);
              this.delegate.finishAttributeValue();
              this.consume();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else if (char === '"' || char === "'" || char === '<') {
              this.delegate.reportSyntaxError(char + ' is not a valid character within attribute names');
              this.consume();
              this.delegate.appendToAttributeName(char);
            } else {
              this.consume();
              this.delegate.appendToAttributeName(char);
            }
          },
          afterAttributeName: function afterAttributeName() {
            var char = this.peek();

            if (isSpace(char)) {
              this.consume();
              return;
            } else if (char === '/') {
              this.delegate.beginAttributeValue(false);
              this.delegate.finishAttributeValue();
              this.consume();
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
            } else if (char === '=') {
              this.consume();
              this.transitionTo("beforeAttributeValue"
              /* beforeAttributeValue */
              );
            } else if (char === '>') {
              this.delegate.beginAttributeValue(false);
              this.delegate.finishAttributeValue();
              this.consume();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.delegate.beginAttributeValue(false);
              this.delegate.finishAttributeValue();
              this.transitionTo("attributeName"
              /* attributeName */
              );
              this.delegate.beginAttribute();
              this.consume();
              this.delegate.appendToAttributeName(char);
            }
          },
          beforeAttributeValue: function beforeAttributeValue() {
            var char = this.peek();

            if (isSpace(char)) {
              this.consume();
            } else if (char === '"') {
              this.transitionTo("attributeValueDoubleQuoted"
              /* attributeValueDoubleQuoted */
              );
              this.delegate.beginAttributeValue(true);
              this.consume();
            } else if (char === "'") {
              this.transitionTo("attributeValueSingleQuoted"
              /* attributeValueSingleQuoted */
              );
              this.delegate.beginAttributeValue(true);
              this.consume();
            } else if (char === '>') {
              this.delegate.beginAttributeValue(false);
              this.delegate.finishAttributeValue();
              this.consume();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.transitionTo("attributeValueUnquoted"
              /* attributeValueUnquoted */
              );
              this.delegate.beginAttributeValue(false);
              this.consume();
              this.delegate.appendToAttributeValue(char);
            }
          },
          attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
            var char = this.consume();

            if (char === '"') {
              this.delegate.finishAttributeValue();
              this.transitionTo("afterAttributeValueQuoted"
              /* afterAttributeValueQuoted */
              );
            } else if (char === '&') {
              this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
            } else {
              this.delegate.appendToAttributeValue(char);
            }
          },
          attributeValueSingleQuoted: function attributeValueSingleQuoted() {
            var char = this.consume();

            if (char === "'") {
              this.delegate.finishAttributeValue();
              this.transitionTo("afterAttributeValueQuoted"
              /* afterAttributeValueQuoted */
              );
            } else if (char === '&') {
              this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
            } else {
              this.delegate.appendToAttributeValue(char);
            }
          },
          attributeValueUnquoted: function attributeValueUnquoted() {
            var char = this.peek();

            if (isSpace(char)) {
              this.delegate.finishAttributeValue();
              this.consume();
              this.transitionTo("beforeAttributeName"
              /* beforeAttributeName */
              );
            } else if (char === '/') {
              this.delegate.finishAttributeValue();
              this.consume();
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
            } else if (char === '&') {
              this.consume();
              this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
            } else if (char === '>') {
              this.delegate.finishAttributeValue();
              this.consume();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.consume();
              this.delegate.appendToAttributeValue(char);
            }
          },
          afterAttributeValueQuoted: function afterAttributeValueQuoted() {
            var char = this.peek();

            if (isSpace(char)) {
              this.consume();
              this.transitionTo("beforeAttributeName"
              /* beforeAttributeName */
              );
            } else if (char === '/') {
              this.consume();
              this.transitionTo("selfClosingStartTag"
              /* selfClosingStartTag */
              );
            } else if (char === '>') {
              this.consume();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.transitionTo("beforeAttributeName"
              /* beforeAttributeName */
              );
            }
          },
          selfClosingStartTag: function selfClosingStartTag() {
            var char = this.peek();

            if (char === '>') {
              this.consume();
              this.delegate.markTagAsSelfClosing();
              this.delegate.finishTag();
              this.transitionTo("beforeData"
              /* beforeData */
              );
            } else {
              this.transitionTo("beforeAttributeName"
              /* beforeAttributeName */
              );
            }
          },
          endTagOpen: function endTagOpen() {
            var char = this.consume();

            if (char === '@' || char === ':' || isAlpha(char)) {
              this.transitionTo("endTagName"
              /* endTagName */
              );
              this.tagNameBuffer = '';
              this.delegate.beginEndTag();
              this.appendToTagName(char);
            }
          }
        };
        this.reset();
      }

      EventedTokenizer.prototype.reset = function () {
        this.transitionTo("beforeData"
        /* beforeData */
        );
        this.input = '';
        this.tagNameBuffer = '';
        this.index = 0;
        this.line = 1;
        this.column = 0;
        this.delegate.reset();
      };

      EventedTokenizer.prototype.transitionTo = function (state) {
        this.state = state;
      };

      EventedTokenizer.prototype.tokenize = function (input) {
        this.reset();
        this.tokenizePart(input);
        this.tokenizeEOF();
      };

      EventedTokenizer.prototype.tokenizePart = function (input) {
        this.input += preprocessInput(input);

        while (this.index < this.input.length) {
          var handler = this.states[this.state];

          if (handler !== undefined) {
            handler.call(this);
          } else {
            throw new Error("unhandled state " + this.state);
          }
        }
      };

      EventedTokenizer.prototype.tokenizeEOF = function () {
        this.flushData();
      };

      EventedTokenizer.prototype.flushData = function () {
        if (this.state === 'data') {
          this.delegate.finishData();
          this.transitionTo("beforeData"
          /* beforeData */
          );
        }
      };

      EventedTokenizer.prototype.peek = function () {
        return this.input.charAt(this.index);
      };

      EventedTokenizer.prototype.consume = function () {
        var char = this.peek();
        this.index++;

        if (char === '\n') {
          this.line++;
          this.column = 0;
        } else {
          this.column++;
        }

        return char;
      };

      EventedTokenizer.prototype.consumeCharRef = function () {
        var endIndex = this.input.indexOf(';', this.index);

        if (endIndex === -1) {
          return;
        }

        var entity = this.input.slice(this.index, endIndex);
        var chars = this.entityParser.parse(entity);

        if (chars) {
          var count = entity.length; // consume the entity chars

          while (count) {
            this.consume();
            count--;
          } // consume the `;`


          this.consume();
          return chars;
        }
      };

      EventedTokenizer.prototype.markTagStart = function () {
        this.delegate.tagOpen();
      };

      EventedTokenizer.prototype.appendToTagName = function (char) {
        this.tagNameBuffer += char;
        this.delegate.appendToTagName(char);
      };

      EventedTokenizer.prototype.isIgnoredEndTag = function () {
        var tag = this.tagNameBuffer;
        return tag === 'title' && this.input.substring(this.index, this.index + 8) !== '</title>' || tag === 'style' && this.input.substring(this.index, this.index + 8) !== '</style>' || tag === 'script' && this.input.substring(this.index, this.index + 9) !== '</script>';
      };

      return EventedTokenizer;
    }();

    var Tokenizer =
    /** @class */
    function () {
      function Tokenizer(entityParser, options) {
        if (options === void 0) {
          options = {};
        }

        this.options = options;
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.tokens = [];
        this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);
        this._currentAttribute = undefined;
      }

      Tokenizer.prototype.tokenize = function (input) {
        this.tokens = [];
        this.tokenizer.tokenize(input);
        return this.tokens;
      };

      Tokenizer.prototype.tokenizePart = function (input) {
        this.tokens = [];
        this.tokenizer.tokenizePart(input);
        return this.tokens;
      };

      Tokenizer.prototype.tokenizeEOF = function () {
        this.tokens = [];
        this.tokenizer.tokenizeEOF();
        return this.tokens[0];
      };

      Tokenizer.prototype.reset = function () {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
      };

      Tokenizer.prototype.current = function () {
        var token = this.token;

        if (token === null) {
          throw new Error('token was unexpectedly null');
        }

        if (arguments.length === 0) {
          return token;
        }

        for (var i = 0; i < arguments.length; i++) {
          if (token.type === arguments[i]) {
            return token;
          }
        }

        throw new Error("token type was unexpectedly " + token.type);
      };

      Tokenizer.prototype.push = function (token) {
        this.token = token;
        this.tokens.push(token);
      };

      Tokenizer.prototype.currentAttribute = function () {
        return this._currentAttribute;
      };

      Tokenizer.prototype.addLocInfo = function () {
        if (this.options.loc) {
          this.current().loc = {
            start: {
              line: this.startLine,
              column: this.startColumn
            },
            end: {
              line: this.tokenizer.line,
              column: this.tokenizer.column
            }
          };
        }

        this.startLine = this.tokenizer.line;
        this.startColumn = this.tokenizer.column;
      }; // Data


      Tokenizer.prototype.beginDoctype = function () {
        this.push({
          type: "Doctype"
          /* Doctype */
          ,
          name: ''
        });
      };

      Tokenizer.prototype.appendToDoctypeName = function (char) {
        this.current("Doctype"
        /* Doctype */
        ).name += char;
      };

      Tokenizer.prototype.appendToDoctypePublicIdentifier = function (char) {
        var doctype = this.current("Doctype"
        /* Doctype */
        );

        if (doctype.publicIdentifier === undefined) {
          doctype.publicIdentifier = char;
        } else {
          doctype.publicIdentifier += char;
        }
      };

      Tokenizer.prototype.appendToDoctypeSystemIdentifier = function (char) {
        var doctype = this.current("Doctype"
        /* Doctype */
        );

        if (doctype.systemIdentifier === undefined) {
          doctype.systemIdentifier = char;
        } else {
          doctype.systemIdentifier += char;
        }
      };

      Tokenizer.prototype.endDoctype = function () {
        this.addLocInfo();
      };

      Tokenizer.prototype.beginData = function () {
        this.push({
          type: "Chars"
          /* Chars */
          ,
          chars: ''
        });
      };

      Tokenizer.prototype.appendToData = function (char) {
        this.current("Chars"
        /* Chars */
        ).chars += char;
      };

      Tokenizer.prototype.finishData = function () {
        this.addLocInfo();
      }; // Comment


      Tokenizer.prototype.beginComment = function () {
        this.push({
          type: "Comment"
          /* Comment */
          ,
          chars: ''
        });
      };

      Tokenizer.prototype.appendToCommentData = function (char) {
        this.current("Comment"
        /* Comment */
        ).chars += char;
      };

      Tokenizer.prototype.finishComment = function () {
        this.addLocInfo();
      }; // Tags - basic


      Tokenizer.prototype.tagOpen = function () {};

      Tokenizer.prototype.beginStartTag = function () {
        this.push({
          type: "StartTag"
          /* StartTag */
          ,
          tagName: '',
          attributes: [],
          selfClosing: false
        });
      };

      Tokenizer.prototype.beginEndTag = function () {
        this.push({
          type: "EndTag"
          /* EndTag */
          ,
          tagName: ''
        });
      };

      Tokenizer.prototype.finishTag = function () {
        this.addLocInfo();
      };

      Tokenizer.prototype.markTagAsSelfClosing = function () {
        this.current("StartTag"
        /* StartTag */
        ).selfClosing = true;
      }; // Tags - name


      Tokenizer.prototype.appendToTagName = function (char) {
        this.current("StartTag"
        /* StartTag */
        , "EndTag"
        /* EndTag */
        ).tagName += char;
      }; // Tags - attributes


      Tokenizer.prototype.beginAttribute = function () {
        this._currentAttribute = ['', '', false];
      };

      Tokenizer.prototype.appendToAttributeName = function (char) {
        this.currentAttribute()[0] += char;
      };

      Tokenizer.prototype.beginAttributeValue = function (isQuoted) {
        this.currentAttribute()[2] = isQuoted;
      };

      Tokenizer.prototype.appendToAttributeValue = function (char) {
        this.currentAttribute()[1] += char;
      };

      Tokenizer.prototype.finishAttributeValue = function () {
        this.current("StartTag"
        /* StartTag */
        ).attributes.push(this._currentAttribute);
      };

      Tokenizer.prototype.reportSyntaxError = function (message) {
        this.current().syntaxError = message;
      };

      return Tokenizer;
    }();

    function tokenize(input, options) {
      var tokenizer = new Tokenizer(new EntityParser(HTML5NamedCharRefs), options);
      return tokenizer.tokenize(input);
    }

    var LinkifyResult = 'LinkifyResult';
    var StartTag = 'StartTag';
    var EndTag = 'EndTag';
    var Chars = 'Chars';
    var Comment = 'Comment';
    var Doctype = 'Doctype';
    /**
     * @param {string} str html string to link
     * @param {import('linkifyjs').Opts} [opts] linkify options
     * @returns {string} resulting string
     */

    function linkifyHtml(str, opts) {
      if (opts === void 0) {
        opts = {};
      }

      // `tokens` and `token` in this section refer to tokens generated by the
      // HTML parser, not linkify's parser
      var tokens = tokenize(str);
      var linkifiedTokens = [];
      var linkified = [];
      var options = new linkifyjs.Options(opts, defaultRender); // Linkify the tokens given by the parser

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (token.type === StartTag) {
          linkifiedTokens.push(token); // Ignore all the contents of ignored tags

          var tagName = token.tagName.toUpperCase();
          var isIgnored = tagName === 'A' || options.ignoreTags.indexOf(tagName) >= 0;

          if (!isIgnored) {
            continue;
          }

          var preskipLen = linkifiedTokens.length;
          skipTagTokens(tagName, tokens, ++i, linkifiedTokens);
          i += linkifiedTokens.length - preskipLen - 1;
        } else if (token.type !== Chars) {
          // Skip this token, it's not important
          linkifiedTokens.push(token);
        } else {
          // Valid text token, linkify it!
          var linkifedChars = linkifyChars(token.chars, options);
          linkifiedTokens.push.apply(linkifiedTokens, linkifedChars);
        }
      } // Convert the tokens back into a string


      for (var _i = 0; _i < linkifiedTokens.length; _i++) {
        var _token = linkifiedTokens[_i];

        switch (_token.type) {
          case LinkifyResult:
            linkified.push(_token.rendered);
            break;

          case StartTag:
            {
              var link = '<' + _token.tagName;

              if (_token.attributes.length > 0) {
                link += ' ' + attributeArrayToStrings(_token.attributes).join(' ');
              }

              if (_token.selfClosing) {
                link += ' /';
              }

              link += '>';
              linkified.push(link);
              break;
            }

          case EndTag:
            linkified.push("</" + _token.tagName + ">");
            break;

          case Chars:
            linkified.push(escapeText(_token.chars));
            break;

          case Comment:
            linkified.push("<!--" + escapeText(_token.chars) + "-->");
            break;

          case Doctype:
            {
              var doctype = "<!DOCTYPE " + _token.name;

              if (_token.publicIdentifier) {
                doctype += " PUBLIC \"" + _token.publicIdentifier + "\"";
              }

              if (_token.systemIdentifier) {
                doctype += " \"" + _token.systemIdentifier + "\"";
              }

              doctype += '>';
              linkified.push(doctype);
              break;
            }
        }
      }

      return linkified.join('');
    }
    /**
    	`tokens` and `token` in this section referes to tokens returned by
    	`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens
    	@param {string}
    	@param {import('linkifyjs').Options}
    */

    function linkifyChars(str, options) {
      var tokens = linkifyjs.tokenize(str);
      var result = [];

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (token.t === 'nl' && options.get('nl2br')) {
          result.push({
            type: StartTag,
            tagName: 'br',
            attributes: [],
            selfClosing: true
          });
        } else if (!token.isLink || !options.check(token)) {
          result.push({
            type: Chars,
            chars: token.toString()
          });
        } else {
          result.push({
            type: LinkifyResult,
            rendered: options.render(token)
          });
        }
      }

      return result;
    }
    /**
    	Returns a list of tokens skipped until the closing tag of tagName.

    	* `tagName` is the closing tag which will prompt us to stop skipping
    	* `tokens` is the array of tokens generated by HTML5Tokenizer which
    	* `i` is the index immediately after the opening tag to skip
    	* `skippedTokens` is an array which skipped tokens are being pushed into

    	Caveats

    	* Assumes that i is the first token after the given opening tagName
    	* The closing tag will be skipped, but nothing after it
    	* Will track whether there is a nested tag of the same type
    */


    function skipTagTokens(tagName, tokens, i, skippedTokens) {
      // number of tokens of this type on the [fictional] stack
      var stackCount = 1;

      while (i < tokens.length && stackCount > 0) {
        var token = tokens[i];

        if (token.type === StartTag && token.tagName.toUpperCase() === tagName) {
          // Nested tag of the same type, "add to stack"
          stackCount++;
        } else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) {
          // Closing tag
          stackCount--;
        }

        skippedTokens.push(token);
        i++;
      } // Note that if stackCount > 0 here, the HTML is probably invalid


      return skippedTokens;
    }

    function defaultRender(_ref) {
      var tagName = _ref.tagName,
          attributes = _ref.attributes,
          content = _ref.content;
      return "<" + tagName + " " + attributesToString(attributes) + ">" + escapeText(content) + "</" + tagName + ">";
    }

    function escapeText(text) {
      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function escapeAttr(attr) {
      return attr.replace(/"/g, '&quot;');
    }

    function attributesToString(attributes) {
      var result = [];

      for (var attr in attributes) {
        var val = attributes[attr] + '';
        result.push(attr + "=\"" + escapeAttr(val) + "\"");
      }

      return result.join(' ');
    }

    function attributeArrayToStrings(attrs) {
      var attrStrs = [];

      for (var i = 0; i < attrs.length; i++) {
        var name = attrs[i][0];
        var value = attrs[i][1] + '';
        attrStrs.push(name + "=\"" + escapeAttr(value) + "\"");
      }

      return attrStrs;
    }

    return linkifyHtml;

})(linkify);

const options = {
  defaultProtocol: "https"
  // ignoreTags: ["img"]
};

document.querySelectorAll(".boardPostMessage").forEach(post => {
  // console.log(post.innerHTML);
  post.innerHTML = linkifyHtml(post.innerHTML, options);
  // post.textContent = linkifyStr(post.textContent);
});
  // let searchStr = "impress\.openneo\.net\/user\/[0-9a-zA-Z\-]+\/closet";
  // [...post.textContent.matchAll(new RegExp(searchStr, 'gi'))].map(a => {});
    // console.log(a);
  //   a.forEach(str => {
  //     linkify(str);
  //   //  const link = document.createElement("a");
  //   //   link.href = "https://"+str;
  //   //   link.textContent = str;
  //   //   post.append(link);
  //   // });
  // });
  // console.log([...post.textContent.matchAll(new RegExp(searchStr, 'gi'))]);